#lang racket

(require "shape.rkt"
         "points.rkt"
         "../commons/coord.rkt"
         "../commons/helper.rkt")

(provide (all-defined-out))

; functions I might need:
; (shape-equal? x y) ; same as "equal?"
; (shape-identical? x y) ; true if any rotation/reflection/translation of x is equal to y 

(define polyo-transformations
  (hash 'fixed null
        'free shape-transformations*
        'one-sided shape-rotations*))

;; enumerate various types of polyominoes
(define (gen-polyo-of n type)
  (cond ((= n 0) null)
        ((= n 1)
         (list (make-monomino)))
        (else
         (remove-duplicate-shapes
          (flatmap shape-extend (gen-polyo-of (- n 1) type))
          (hash-ref polyo-transformations type)))))

;; enumerate fixed polyominoes with n cells
(define (gen-fixed-polyo-of n)
  (cond ((= n 0) null)
        ((= n 1)
         (list (make-monomino)))
        (else
         (remove-duplicates
          (flatmap shape-extend (gen-fixed-polyo-of (- n 1)))))))

;; enumerate the collection of fixed polyominoes up to n cells
(define (gen-fixed-polyo-upto n)
  (cond ((= n 0) null)
        ((= n 1)
         (list (list (make-monomino))))
        (else
         (let* ((prev-collection
                 (gen-fixed-polyo-upto (- n 1)))
                (prev-set (car prev-collection)))
           (cons (remove-duplicates
                  (flatmap shape-extend prev-set))
                 prev-collection)))))

;; enumerate free polyominoes with n cells
(define (gen-free-polyo-of n)
  (cond ((= n 0) null)
        ((= n 1)
         (list (make-monomino)))
        (else
         (remove-identical-shapes
          (flatmap shape-extend (gen-free-polyo-of (- n 1)))))))

;; enumerate the collection of free polyominoes up to n cells
(define (gen-free-polyo-upto n)
  (cond ((= n 0) null)
        ((= n 1)
         (list (list (make-monomino))))
        (else
         (let* ((prev-collection
                 (gen-free-polyo-upto (- n 1)))
                (prev-set (car prev-collection)))
           (cons (remove-identical-shapes
                  (flatmap shape-extend prev-set))
                 prev-collection)))))

;; monomino
(define (make-monomino)
  (make-shape (list (coord 0 0))))

;; extend a shape at it's point p to the direction vec,
;; where vec can be:
;;   (1, 0) - extend to the right
;;   (-1, 0) - extend to the left
;;   (0, 1) - extend downward
;;   (0, -1) - extend upward
;; return 'FAIL if there is already a point in the desired direction
(define (shape-extend-point-toward s p vec)
  (let* ((points (shape-points s))
         (vec-x (coord-x vec))
         (vec-y (coord-y vec))
         (shift-vec
          ;; when extending the left or upper edge outward,
          ;; shift the original points by 1 unit so the new point can fit in
          (cond ((and (< vec-x 0) (= (coord-x p) 0))
                 (coord (- vec-x) vec-y))
                ((and (< vec-y 0) (= (coord-y p) 0))
                 (coord vec-x (- vec-y)))
                (else null))))
    (if (null? shift-vec)
        (let ((new-shape
               (make-shape (adjoin-points (coord-shift p vec) points))))
          (if (= (shape-weight new-shape) (shape-weight s))
              'FAIL
              new-shape))
        (make-shape (adjoin-points p (points-shift points shift-vec))))))

(define (shape-extend-point s p)
  (let ((directions (list (coord -1 0)
                          (coord 1 0)
                          (coord 0 1)
                          (coord 0 -1))))
    (remove-duplicates
     (filter shape? ;; filter out 'FAIL ones
             (map (lambda (direction)
                    (shape-extend-point-toward s p direction))
                  directions)))))

;; return all shapes generated by adding an adjacent cell to s
;; duplicates are removed
(define (shape-extend s)
  (remove-duplicates
   (flatmap (lambda (p) (shape-extend-point s p)) (shape-points s))))
